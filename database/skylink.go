package database

import (
	"time"

	accdb "github.com/SkynetLabs/skynet-accounts/database"
	"gitlab.com/NebulousLabs/errors"
	"gitlab.com/SkynetLabs/skyd/skymodules"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.sia.tech/siad/crypto"
)

var (
	// ErrInvalidSkylink is the error returned when the passed skylink is
	// invalid.
	ErrInvalidSkylink = "invalid skylink"

	// SkylinkStatusNew is the status of the skylink when it's created.
	SkylinkStatusNew = "new"
	// SkylinkStatusScanning is the status of the skylink while it's being
	// scanned.
	SkylinkStatusScanning = "scanning"
	// SkylinkStatusComplete is the status of the skylink after it's scanned.
	SkylinkStatusComplete = "complete"
)

// Skylink represents a skylink in the queue and holds its scanning status.
type Skylink struct {
	ID                   primitive.ObjectID `bson:"_id,omitempty" json:"-"`
	Hash                 crypto.Hash        `bson:"hash" json:"hash"`
	Skylink              string             `bson:"skylink" json:"skylink"`
	Status               string             `bson:"status" json:"status"`
	Infected             bool               `bson:"infected" json:"infected"`
	InfectionDescription string             `bson:"infection_description" json:"infection_description"`
	// Timestamp marks the last status change that happened to the record. It
	// can be the time when it was created, locked for scanning, or scanned.
	Timestamp time.Time `bson:"timestamp" json:"timestamp"`
}

// LoadString parses a skylink from string and populates all required fields.
func (s *Skylink) LoadString(skylink string) error {
	if !accdb.ValidSkylinkHash(skylink) {
		return errors.New(ErrInvalidSkylink)
	}
	s.Skylink = skylink
	var sl skymodules.Skylink
	err := sl.LoadString(skylink)
	if err != nil {
		return errors.AddContext(err, ErrInvalidSkylink)
	}
	s.Hash = crypto.HashObject(sl.MerkleRoot())
	if s.Timestamp.IsZero() {
		s.Timestamp = time.Now().UTC()
	}
	if s.Status == "" {
		s.Status = SkylinkStatusNew
	}
	return nil
}
