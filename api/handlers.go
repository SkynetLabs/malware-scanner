package api

import (
	"net/http"
	"time"

	"github.com/SkynetLabs/scanner-queue/database"
	accdb "github.com/SkynetLabs/skynet-accounts/database"
	"github.com/julienschmidt/httprouter"
	"gitlab.com/NebulousLabs/errors"
	skyapi "gitlab.com/SkynetLabs/skyd/node/api"
	"go.mongodb.org/mongo-driver/mongo"
)

// ScanPOST adds a new skylink to the scanning queue. If the skylink is already
// in the queue we respond with 200 OK but we don't add it again.
func (api *API) ScanPOST(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	skylink := ps.ByName("skylink")
	if skylink == "" {
		skyapi.WriteError(w, skyapi.Error{"missing required parameter 'skylink'"}, http.StatusBadRequest)
		return
	}
	if !accdb.ValidSkylinkHash(skylink) {
		skyapi.WriteError(w, skyapi.Error{"invalid skylink"}, http.StatusBadRequest)
		return
	}
	sl := &database.Skylink{
		Skylink:   skylink,
		Timestamp: time.Now().UTC(),
		Status:    database.SkylinkStatusNew,
	}
	err := api.db.SkylinkCreate(r.Context(), sl)
	if err != nil {
		skyapi.WriteError(w, skyapi.Error{err.Error()}, http.StatusInternalServerError)
		return
	}
	api.logger.Debugf("Added skylink %s", sl.Skylink)
	skyapi.WriteSuccess(w)
}

// ScanPUT updates a skylink in the queue. If the skylink is not yet in the
// queue it gets added to it.
func (api *API) ScanPUT(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	skylink := ps.ByName("skylink")
	if skylink == "" {
		skyapi.WriteError(w, skyapi.Error{"missing required parameter 'skylink'"}, http.StatusBadRequest)
		return
	}
	if !accdb.ValidSkylinkHash(skylink) {
		skyapi.WriteError(w, skyapi.Error{"invalid skylink"}, http.StatusBadRequest)
		return
	}
	status := r.PostFormValue("status")
	if !StatusIsValid(status) {
		skyapi.WriteError(w, skyapi.Error{"invalid status"}, http.StatusBadRequest)
		return
	}
	category := r.PostFormValue("category")
	if !CategoryIsValid(category) {
		skyapi.WriteError(w, skyapi.Error{"invalid category"}, http.StatusBadRequest)
		return
	}
	// Fetch the skylink record from the database.
	sl, err := api.db.Skylink(r.Context(), skylink)
	if errors.Contains(err, mongo.ErrNoDocuments) {
		skyapi.WriteError(w, skyapi.Error{err.Error()}, http.StatusNotFound)
		return
	}
	if err != nil {
		skyapi.WriteError(w, skyapi.Error{err.Error()}, http.StatusInternalServerError)
		return
	}
	// Check for invalid status transitions.
	// The flow should always be new->scanning->complete.
	if (sl.Status != database.SkylinkStatusNew && status == database.SkylinkStatusNew) ||
		(sl.Status == database.SkylinkStatusComplete && status == database.SkylinkStatusScanning) {
		skyapi.WriteError(w, skyapi.Error{"invalid status transition"}, http.StatusBadRequest)
		return
	}
	sl.Status = status
	sl.Category = category
	sl.Timestamp = time.Now().UTC()
	// Save the updated record in the database.
	err = api.db.SkylinkSave(r.Context(), sl)
	if err != nil {
		skyapi.WriteError(w, skyapi.Error{err.Error()}, http.StatusInternalServerError)
		return
	}
	api.logger.Debugf("Updated skylink %s", sl.Skylink)
	skyapi.WriteSuccess(w)
}

// CategoryIsValid checks whether the category has one of the predefined valid
// values.
func CategoryIsValid(s string) bool {
	switch s {
	case database.CategorySafe:
		return true
	case database.CategoryMalicious:
		return true
	case database.CategorySuspicious:
		return true
	case database.CategoryPUA:
		return true
	}
	return false
}

// StatusIsValid checks whether the status has one of the predefined valid
// values.
func StatusIsValid(s string) bool {
	switch s {
	case database.SkylinkStatusNew:
		return true
	case database.SkylinkStatusScanning:
		return true
	case database.SkylinkStatusComplete:
		return true
	}
	return false
}
